# **프로젝트 계획: 블로그 생성 에이전트 업그레이드**

## **1. 개요 (Overview)**

이 문서는 기존 블로그 생성 애플리케이션을 architecture.md에 정의된 고급 아키텍처로 업그레이드하기 위한 구체적인 실행 계획을 정의합니다. 목표는 성능 병목 현상을 해결하고, LangGraph를 사용하여 보다 강력한 에이전트 로직을 구현하며, 사용자 경험을 대폭 개선하는 것입니다.

**주요 목표:**

* **성능:** Redis 캐싱 및 영속성 벡터 DB를 통해 응답 시간을 단축합니다.  
* **모듈성:** LangGraph를 도입하여 에이전트의 로직을 상태 머신으로 재구성합니다.  
* **사용성:** 스트리밍 응답, 실시간 편집, 모델 선택 등 고급 UI 기능을 구현합니다.  
* **확장성:** 향후 기능 추가(MCP 도구 호출, 프롬프트 관리)를 위한 기반을 마련합니다.

## **2. 프로젝트 요구사항 (Requirements)**

### **2.1. 신규 의존성 (New Dependencies)**

아래 라이브러리들을 pyproject.toml에 추가하고 poetry install을 실행해야 합니다.

[tool.poetry.dependencies]  
# ... 기존 의존성 ...  
langgraph = "^0.0.30"  
langchain-redis = "^0.1.1"  
redis = "^5.0.3"  
streamlit-ace = "^0.1.1"  # 실시간 에디터 기능용

### **2.2. 인프라 (Infrastructure)**

* **Redis Server:** 영속성 캐시 및 벡터 데이터베이스로 사용하기 위해 Redis 인스턴스가 필요합니다. 개발 환경에서는 Docker를 사용하는 것을 권장합니다.  
  # Redis Stack: 벡터 검색 기능 포함  
  docker run -d --name redis-stack -p 6379:6379 -p 8001:8001 redis/redis-stack:latest

## **3. 단계별 실행 계획 (Phased Implementation Plan)**

작업을 관리하기 쉬운 주요 섹션으로 나누었습니다. 각 단계는 독립적으로 완료될 수 있도록 설계되었습니다.

### **Phase 1: 기반 성능 강화 (약 3-4 시간)**

**목표:** 백엔드의 데이터 처리 속도를 최적화하여 이후 작업의 기반을 마련합니다.

* [X] **Task 1.1: 영속성 벡터 스토어 구현**  
  * **세부사항:** src/vector_store.py를 수정하여 ChromaDB가 디스크에 데이터를 저장하도록 설정합니다. 이를 통해 앱 재시작 시 문서 재임베딩 과정을 제거합니다.  
  * **핵심 변경:** Chroma 생성자에 persist_directory 인자를 추가합니다.  
* [X] **Task 1.2: Redis를 이용한 영속성 캐시 설정**  
  * **세부사항:** Redis를 LangChain의 글로벌 캐시로 설정합니다. 이를 통해 모든 LLM 및 도구 호출 결과가 캐시되어 반복적인 요청에 대한 응답 시간을 대폭 단축합니다.  
  * **핵심 변경:** src/app.py 또는 새로운 src/caching.py 모듈에서 애플리케이션 시작 시 set_llm_cache를 호출하도록 설정합니다.

### **Phase 2: 핵심 로직 재설계: LangGraph 도입 (약 6-8 시간)**

**목표:** AgentExecutor를 LangGraph 상태 머신으로 대체하여 에이전트의 제어 흐름을 명시적으로 만듭니다.

* [X] **Task 2.1: 에이전트 상태(State) 및 노드(Node) 정의**  
  * **세부사항:** src/graph.py 파일을 생성합니다. AgentState TypedDict를 정의하여 그래프 내에서 전달될 데이터 구조(초안, 채팅 기록 등)를 명시합니다. 각 로직(라우터, 단순 수정, 도구 호출)을 독립된 함수(노드)로 구현합니다.  
* [X] **Task 2.2: 그래프 구성 및 컴파일**  
  * **세부사항:** src/graph.py에서 StateGraph를 생성하고, 정의된 노드와 엣지(라우터의 결정에 따른 분기)를 추가합니다. 최종적으로 그래프를 컴파일하여 실행 가능한 Runnable 객체를 만듭니다.  
* [X] **Task 2.3: 에이전트에 그래프 통합**  
  * **세부사항:** src/agent.py를 리팩토링합니다. update_blog_post 메소드가 컴파일된 LangGraph를 호출하도록 수정합니다. 기존 AgentExecutor 관련 로직은 제거됩니다.

### **Phase 3: 사용자 경험(UI/UX) 혁신 (약 5-7 시간)**

**목표:** 사용자 인터페이스를 현대적이고 상호작용적으로 개선합니다.

* [X] **Task 3.1: UI 흐름 개선 (모델 선택 및 선택적 로그인)**  
  * **세부사항:** 사이드바에 모델 선택 st.selectbox를 추가합니다. 로그인 화면을 제거하고, 사이드바에 "로그인" 버튼을 두어 필요시 팝업 또는 별도 화면으로 인증을 처리하도록 변경합니다.  
* [ ] **Task 3.2: 응답 스트리밍 구현**  # DEBUG
  * **세부사항:** LangGraph의 마지막 노드가 응답을 스트리밍하도록 수정합니다 (graph.stream() 호출). UI(contents_editor.py)에서는 st.write_stream을 사용하여 LLM의 응답을 토큰 단위로 실시간 표시합니다.  
* [ ] **Task 3.3: 실시간 에디터 및 Undo/Redo 기능 구현**  
  * **세부사항:** st.text_area를 streamlit-ace 에디터 컴포넌트로 교체하여 더 나은 편집 경험을 제공합니다. st.session_state에 초안의 변경 내역을 리스트로 저장하여 Undo/Redo 버튼 기능을 구현합니다.  
* [ ] **Task 3.4: 마크다운 파일 다운로드 기능 추가**  
  * **세부사항:** UI에 st.download_button을 추가하여 현재 편집 중인 블로그 초안을 .md 파일로 다운로드할 수 있게 합니다.

### **Phase 4: 고급 기능 통합 및 마무리 (약 3-4 시간)**

**목표:** 에이전트의 능력을 확장하고 향후 관리를 용이하게 합니다.

* [ ] **Task 4.1: 프롬프트 템플릿 고도화 (시스템 프롬프트 분리)**  
  * **세부사항:** prompts.yaml 구조를 변경하여 "시스템 프롬프트" 섹션을 명시적으로 분리합니다. 이를 통해 에이전트의 역할과 지침을 더욱 명확하게 정의하고, 응답의 전문성을 높입니다.  
* [ ] **Task 4.2: MCP(Model-Chosen Parameters) 도구 호출 탐색**  
  * **세부사항:** 도구의 Pydantic 스키마에 선택적 파라미터를 추가하여 LLM이 도구를 더 세밀하게 제어할 수 있도록 합니다 (예: 검색 시 search_type을 'news' 또는 'academic'으로 선택).

## **4. 추가 질문에 대한 답변**

### **Q: 이 작업을 다른 AI에게 어떻게 위임할 수 있나요? 추천할 만한 방법인가요?**

**A:** **매우 추천합니다.** 이 계획은 작업을 자연스럽게 위임할 수 있도록 모듈식으로 구성되어 있습니다.

* **방법:** 각 Task(예: "Task 1.1: 영속성 벡터 스토어 구현")를 독립적인 작업 단위로 삼으세요. 다른 AI 어시스턴트에게 해당 Task의 목표, 요구사항, 그리고 관련된 핵심 파일(src/vector_store.py, src/config.py)을 컨텍스트로 제공하세요. AI는 해당 파일에 대한 수정 코드를 생성할 것입니다.  
* **장점:** 이 접근 방식은 복잡한 프로젝트를 병렬로 처리하고, 각 AI가 특정 컨텍스트에만 집중하게 하여 더 정확하고 빠른 코드 생성을 유도합니다.

### **Q: 작업 진행 상황 컨텍스트는 어떻게 저장할 수 있나요?**

**A:** **이 project_plan.md 파일 자체가 우리의 진행 상황 컨텍스트입니다.** 각 Task를 완료할 때마다 체크박스([ ] -> [x])를 업데이트하세요. 다음 작업 세션을 시작할 때, 이 업데이트된 문서를 저에게 다시 제공하면, 우리는 어디서부터 다시 시작해야 할지, 어떤 작업이 남았는지 정확히 파악할 수 있습니다. 이 문서가 우리의 "공유 메모리" 역할을 합니다.

### **Q: 설정 중앙화는 모든 작업이 끝난 후에 하는 것이 더 나은가요?**

**A:** **아니요, 지금 바로 시작하고 점진적으로 수행하는 것이 가장 좋습니다.** 아키텍처를 변경하면서 새로운 설정(예: Redis 호스트 주소, LangGraph 설정)이 필요해질 때마다 즉시 config.yaml에 추가하는 것이 현대적인 개발 방식입니다.

* **이유:** 나중에 한 번에 모든 설정을 중앙화하려고 하면, 코드 곳곳에 하드코딩된 값을 찾아내고 리팩토링하는 데 훨씬 더 많은 시간과 노력이 소요됩니다. 처음부터 설정을 분리하면 코드가 깨끗하게 유지되고, 개발 환경과 프로덕션 환경 간의 전환이 매우 쉬워집니다.